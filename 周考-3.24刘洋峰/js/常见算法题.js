// 双色球：
// 	描述：
// 	一注完整的双色球彩票号码由6个红色号码,1个蓝色号码组成(共7个数字)
// 	6个红色号码在[1-33]范围内随机产生, 1个蓝色号码在[1-16]范围内随机产生
	
// 	正确编写生成双色球号码函数createLottery,可以接收参数n
// 	对于createLottery函数,传入参数1,可以正确生成1注彩票号码并打印输出
// 	对于createLottery函数,传入参数5,可以正确生成5注彩票号码并打印输出








// 随机获取n个不重复的数组项
// 描述，写randomArray函数，传递一个数组，传递一个数值，返回一个指定个数的随机的新数组，不允许有重复数据
// 用例：
// randomArray([
//    '小明', '小红', '小绿', '小白', '小黄', '小蓝', '小黑', '小青'
// ], 3)
// 结果：
// ['小红', '小白', '小明']

//随机数组或字符串的下标  Math.floor(Math.random()*arr.length)   数组   下标
//随机数组  arr[Math.floor(Math.random()*arr.length)]





// 去重求和
// 完成getSum(),该函数接收1个数组作为参数，返回该数组中所有非重复数字的和；
// 例如：getSum([undefined,"23year",19,"097",1,"hello",null,1])  // return 20
// 思路：1）定义一个新数组；2）遍历数组的每一项，然后判断是否在新数组中存在（indexOf），并且是数字，3）如果是添加到新数组中(push)，并且，用sum加上当前遍历的项






// 字符串去重
// 编写函数uniq(str)，返回去掉str重复项的字符串。
// 例如，uniq(‘12223333’)将返回’123’






// arguemtns 多参数求和
// 封装一个函数：传入多个一维数组作为参数，实现求参数的和sum2([1, 2, 3],[4, 5, 6],[7, 8, 9])




// 每个数组参数中的最大值
// 封装一个largestOfFour函数，将一个二维数组作为该函数的参数，这个二维数组中包含了4个小数组，
// 分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。
// 调用：largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]) //返回值[5,27,39,1001]







// arguments 多参数去重
// 封装一个函数unite()，传入两个或两个以上的数组，返回一个以给定的原数组排序的不包含重复值的新数组。
	    // 说明：所有数组中的左右值都应该以原始顺序被包含在内，但是在最终的数组中不包含重复值。	
	    // 例如：unite([1,3,2],[5,2,1,4],[2,1]) //返回结果：[1,3,2,5,4]
		    //  unite([1,2,3],[5,2,1,4],[2,1],[6,7,8])  //返回结果:[1,2,3,5,4,6,7,8]



// 一维转二维（size）
// (一维转二维)封装一个chunk(arr,size)的函数，把该数组arr按照指定的size分割成若干个数组块。
// 例如：chunk([1,2,3,4],2) 返回结果:[[1,2],[3,4]]
//     chunk([1,2,3,4,5,6],3) 返回结果:[[1,2,3],[4,5,6]]






// 一维数组转二维（重复项一起）
// 编写一个方法将一维数组转化成二维数组，（将数组中的重复项合并到一个新数组，最后拼接成一个二维数组）
// Var arr = [1,2,3,2,2,2,3,3,4]
// 经过转换后结果:[[1],[2,2,2,2],[3,3,3],[4]]






// 碱基：
// 封装一个函数pair(str)，实现如下功能：
// Base Pairs是一对AT和CG，为给定的字母匹配正确的碱基。
// 例：pair("ATCG")  //返回值[["A","T"],["T","A"],["C","G"],["G","C"]]
// pair("CTCTA") //返回值[["C","G"],["T","A"],["C","G"],["T","A"],["A","T"]]






// （去重）
// 封装一个函数noRepeat(arr)，实现将数组中重复的值只保留一个，且做升序排列，
// var num = [1,2,7,8,9,2,3,3,5,6,7,5,3] 
// 例如：noRepeat(nums)  返回[1,2,3,5,6,7,8,9]
// 原理：定义一个新数组，利用indexOf()方法
// 	遍历数组，判断数组的每一项是否在新数组中存在，如果不存在，就添加到新数组中；
// 即判断arr[i]在arrs中位置是否为-1；如果未-1；证明不存在；那么就添加





// 实现reverse封装
// 分析：从下标为0的位置开始遍历（正序遍历）；然后利用unshift()实现
// 分析2：从最后一个下标开始遍历（倒序遍历）；然后利用push（）实现






// 题目 （去重不用indexOf）
// 编写一个函数 unique(arr)，返回一个去除数组内重复的元素的数组（不能使用indexof方法）例如：
// unique([0, 1, 2, 2, 3, 3, 4]) // => [0, 1, 2, 3, 4]
// unique([0, 1, '1', '1', 2]) // => [0, 1, '1', 2]






// （冒泡）
// 封装一个排序方法, 可实现数组的内容从小到大排序（sort的封装）
// 冒泡原理：相邻两项进行比较，如果前一个大于后一个，那么交换一下位置；








// 二维数组的应用
// 封装一个format 函数,传入一个长度相等的一维数组组成的二维数组作为参数，在函数内部按照下面实例对该二维数组进行格式化，最后将格式化的结果返出来。 
// 1）例：定义一个二维数组source1=[[1,2,3],[4,5,6],[7,8,9]],执行format(source1)的返回结果是：[[1,4,7],[2,5,8],[3,6,9]]
// 2）例：定义一个二维数组source2=[[1,2],[3,4],[5,6]],执行format（source2）的返回结果是：[[1,3,5],[2,4,6]]
// 3）例：定义一个二维数组source3=[[1,2,3,4],[5,6,7,8]]执行format（source3）的返回结果是：[[1,5],[2,6],[3,7],[4,8]];








// 变形
// var  arr = [[1,2,3,4],["A","B","C",D],["东","南","西","北"]];                                                    
// (1)Console.log(fun(arr)); 函数封装，打印出来如下效果  
//[[1,"A","东"],[2,"B","南"],[3,"C","西"],[4,"D","北"]]; 





// 按长度排序 
// 封装一个lengthSort函数，接收一个数组作为参数，，数组的每一项都是一个单词，按照单词的长度，从大到小对数组排序







// 找最长单词
// 封装一个findLongestWord(str)函数，str是个英文句子，实现如下功能：找出str句子中最长的单词，并计算它的长度。
// 例如。"The quick brown fox jumped over the lazy dog." 
// findLongestWord("The quick brown fox jumped over the lazy dog."); //6            
// findLongestWord("I believe I can do it.");//7